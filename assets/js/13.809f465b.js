(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{578:function(e,v,_){"use strict";_.r(v);var o=_(5),s=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"_1-术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-术语"}},[e._v("#")]),e._v(" 1.术语")]),e._v(" "),_("p",[e._v("1.1. "),_("code",[e._v("promise")]),e._v(" 是一个对象或者函数，并且拥有符合本规范的 "),_("code",[e._v("then")]),e._v(" 方法。")]),e._v(" "),_("p",[e._v("1.2. "),_("code",[e._v("thenable")]),e._v(" 是定义 "),_("code",[e._v("then")]),e._v(" 方法的对象或者函数。")]),e._v(" "),_("p",[e._v("1.3. "),_("code",[e._v("value")]),e._v(" 是任意合法的 JavaScript 值，（包括 undefined，thenable，promise）")]),e._v(" "),_("p",[e._v("1.4 "),_("code",[e._v("exception")]),e._v(" 是使用"),_("code",[e._v("throw")]),e._v("语句抛出的值")]),e._v(" "),_("p",[e._v("1.5 "),_("code",[e._v("reason")]),e._v(" 表示一个"),_("code",[e._v("promise")]),e._v(" 被拒绝的原因。")]),e._v(" "),_("h2",{attrs:{id:"_2-要求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-要求"}},[e._v("#")]),e._v(" 2.要求")]),e._v(" "),_("h3",{attrs:{id:"_2-1-promise-状态-states"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise-状态-states"}},[e._v("#")]),e._v(" 2.1. Promise 状态（states）")]),e._v(" "),_("p",[e._v("一个 Promise 的状态必须为以下三种状态之一："),_("strong",[e._v("等待态（Pending）")]),e._v(" 、"),_("strong",[e._v("完成态（Fulfilled")]),e._v("） 和 "),_("strong",[e._v("拒绝态（Rejected）")]),e._v(" 。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.1.1. 当 "),_("strong",[e._v("promise")]),e._v(" 是"),_("strong",[e._v("准备态（Pending）")]),e._v(" 时")]),e._v(" "),_("ul",[_("li",[e._v("2.1.1.1. 可以改变为 完成态（Fulfilled）或者 拒接态（Rejected）")])])]),e._v(" "),_("li",[_("p",[e._v("2.1.2 当 "),_("strong",[e._v("promise")]),e._v(" 是 "),_("strong",[e._v("完成态（Fulfilled）")]),e._v(" 时")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.1.2.1 promise 不能改变为其他状态")])]),e._v(" "),_("li",[_("p",[e._v("2.1.2.2 必须有一个 "),_("strong",[e._v("值（value）")]),e._v(" ，并且不能改变")])])])]),e._v(" "),_("li",[_("p",[e._v("2.1.3 当 "),_("strong",[e._v("promise")]),e._v(" 是 "),_("strong",[e._v("拒接态（Rejected）")]),e._v(" 时")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.1.3.1 promise 不能改变为其他状态")])]),e._v(" "),_("li",[_("p",[e._v("2.1.3.2 必须有一个 "),_("strong",[e._v("原因（reason）")]),e._v(" ， 并且不能改变")])])])])]),e._v(" "),_("p",[e._v("这里的不能改变指的是恒等（即可用 "),_("code",[e._v("===")]),e._v(" 判断相等），而不是意味着更深层次的不能改变（指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）")]),e._v(" "),_("h3",{attrs:{id:"_2-2-then-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-then-方法"}},[e._v("#")]),e._v(" 2.2. "),_("code",[e._v("then")]),e._v(" 方法")]),e._v(" "),_("p",[e._v("一个 "),_("code",[e._v("promise")]),e._v(" 必须提供一个 "),_("code",[e._v("then")]),e._v(" 方法来"),_("strong",[e._v("接收它当前 完成的值（value） 或者 拒绝的原因（reason）")]),e._v("\n每一个 "),_("code",[e._v("promise")]),e._v(" 的 "),_("code",[e._v("then")]),e._v(" 方法 都接收 两个参数：")]),e._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[e._v("   promise"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("ul",[_("li",[_("p",[e._v("2.2.1. "),_("code",[e._v("onFulfilled")]),e._v("和"),_("code",[e._v("onRejected")]),e._v(" 都是可选参数：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.2.1.1 如果 "),_("code",[e._v("onFulfilled")]),e._v(" 不是函数，则必须忽略")])]),e._v(" "),_("li",[_("p",[e._v("2.2.1.2 如果 "),_("code",[e._v("onRejected")]),e._v(" 不是函数，则必须忽略")])])])]),e._v(" "),_("li",[_("p",[e._v("2.2.2. 如果 "),_("code",[e._v("onFulfilled")]),e._v(" 是一个函数：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.2.2.1 此函数必须在 "),_("code",[e._v("promise")]),e._v(" 完成（Fulfilled）后被调用，以 "),_("code",[e._v("promise")]),e._v(" 的值（value）作为它的第一个参数")])]),e._v(" "),_("li",[_("p",[e._v("2.2.2.2 此函数在 "),_("code",[e._v("promise")]),e._v(" 完成（Fulfilled）之前一定不能被调用")])]),e._v(" "),_("li",[_("p",[e._v("2.2.2.3 此函数只能被调用一次")])])])]),e._v(" "),_("li",[_("p",[e._v("2.2.3. 如果 "),_("code",[e._v("onRejected")]),e._v(" 是一个函数：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.2.3.1 此函数必须在 "),_("code",[e._v("promise")]),e._v(" 拒绝（Rejected）后被调用，以 "),_("code",[e._v("promise")]),e._v(" 拒绝的原因（reason）作为它的第一个参数")])]),e._v(" "),_("li",[_("p",[e._v("2.2.3.2 此函数在 "),_("code",[e._v("promise")]),e._v(" 拒绝（Rejected）之前一定不能被调用")])]),e._v(" "),_("li",[_("p",[e._v("2.2.3.3 此函数只能被调用一次")])])])]),e._v(" "),_("li",[_("p",[e._v("2.2.4. 在执行上下文堆栈仅包含"),_("strong",[e._v("平台代码")]),e._v("之前，不得调用 "),_("code",[e._v("onFulfilled")]),e._v(" 和 "),_("code",[e._v("onRejected")]),e._v(" [注释3.1]")])]),e._v(" "),_("li",[_("p",[e._v("2.2.5. "),_("code",[e._v("onFulfilled")]),e._v(" 和 "),_("code",[e._v("onRejected")]),e._v(" 必须被作为函数调用（即 没有 this 值）[注释3.2]")])]),e._v(" "),_("li",[_("p",[e._v("2.2.6. "),_("code",[e._v("then")]),e._v(" 方法可以在同一个 "),_("code",[e._v("promise")]),e._v(" 里调用多次")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.2.6.1 如果/当 "),_("code",[e._v("promise")]),e._v(" 完成（Fulfilled）时，所有相应的 "),_("code",[e._v("onFulfilled")]),e._v(" 回调必须按照 then 的顺序依次执行。")])]),e._v(" "),_("li",[_("p",[e._v("2.2.6.2 如果/当 "),_("code",[e._v("promise")]),e._v(" 拒绝（Rejected）时，所有相应的 "),_("code",[e._v("onRejected")]),e._v(" 回调必须按照 "),_("code",[e._v("then")]),e._v(" 的顺序依次执行。")])])])]),e._v(" "),_("li",[_("p",[e._v("2.2.7. "),_("code",[e._v("then")]),e._v(" 方法必须返回一个 "),_("code",[e._v("promise")]),e._v(" [注释3.3]")]),e._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[e._v("    promise2 "),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" promise1"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br")])]),_("ul",[_("li",[_("p",[e._v("2.2.7.1 如果 "),_("code",[e._v("onFulfilled")]),e._v(" 或 "),_("code",[e._v("onRejected")]),e._v(" 返回一个值 "),_("code",[e._v("x")]),e._v("，则运行下面的 "),_("strong",[e._v("Promise 解决过程")]),e._v("："),_("code",[e._v("[[Resolve]](promise2, x)")]),e._v(" [注释2.3]")])]),e._v(" "),_("li",[_("p",[e._v("2.2.7.2 如果 "),_("code",[e._v("onFulfilled")]),e._v(" 或者 "),_("code",[e._v("onRejected")]),e._v(" 抛出一个异常 "),_("code",[e._v("e")]),e._v(" ，则 "),_("code",[e._v("promise2")]),e._v(" 必须拒绝（Rejected），并返回异常 "),_("code",[e._v("e")]),e._v(" 的原因（reason）")])]),e._v(" "),_("li",[_("p",[e._v("2.2.7.3 如果 "),_("code",[e._v("onFulfilled")]),e._v(" 不是函数且 "),_("code",[e._v("promise1")]),e._v(" 完成（Fulfilled）执行， "),_("code",[e._v("promise2")]),e._v(" 必须完成（Fulfilled）执行，并返回和 "),_("code",[e._v("promise1")]),e._v(" 相同的值（value")])]),e._v(" "),_("li",[_("p",[e._v("2.2.7.4 如果 "),_("code",[e._v("onRejected")]),e._v(" 不是函数且 "),_("code",[e._v("peomise1")]),e._v(" 是拒绝（Rejected）状态，"),_("code",[e._v("promise2")]),e._v(" 也必须拒绝（Rejected），并返回和 "),_("code",[e._v("promise1")]),e._v(" 相同的原因（reason）")])])])])]),e._v(" "),_("h3",{attrs:{id:"_2-3-promise-解决过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-promise-解决过程"}},[e._v("#")]),e._v(" 2.3. Promise 解决过程")]),e._v(" "),_("p",[_("strong",[e._v("Promise 解决过程")]),e._v(" 是一个抽象的操作，其需输入一个 "),_("code",[e._v("promise")]),e._v("和一个值（value），我们表示为 "),_("code",[e._v("[[Resolve]](promise, x)")]),e._v("，如果 "),_("code",[e._v("x")]),e._v(" 有 "),_("code",[e._v("then")]),e._v(" 方法且看上去像一个 "),_("code",[e._v("Promise")]),e._v(" ，解决程序即尝试使 "),_("code",[e._v("promise")]),e._v(" 接受 "),_("code",[e._v("x")]),e._v(" 的状态；否则其用 "),_("code",[e._v("x")]),e._v(" 的值来执行 "),_("code",[e._v("promise")]),e._v(" 。")]),e._v(" "),_("p",[e._v("这种 "),_("code",[e._v("thenable")]),e._v(" 的特性使得 "),_("code",[e._v("Promise")]),e._v(" 的实现更具有通用性：只要其暴露出一个遵循 "),_("code",[e._v("Promise/A+")]),e._v(" 协议的 "),_("code",[e._v("then")]),e._v(" 方法即可；这同时也使遵循 "),_("code",[e._v("Promise/A+")]),e._v(" 规范的实现可以与那些不太规范但可用的实现能良好共存。")]),e._v(" "),_("p",[e._v("运行 "),_("code",[e._v("[[Resolve]](promise, x)")]),e._v(" 需遵循以下步骤：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.3.1. 如果 "),_("code",[e._v("promise")]),e._v(" 和 "),_("code",[e._v("x")]),e._v(" 指向同一对象，以 "),_("code",[e._v("TypeError")]),e._v(" 为原因拒绝执行 "),_("code",[e._v("promise")])])]),e._v(" "),_("li",[_("p",[e._v("2.3.2. 如果 "),_("code",[e._v("x")]),e._v(" 是一个 "),_("code",[e._v("promise")]),e._v(" , 那么就采用他的状态[注释3.4]：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.3.2.1 如果 "),_("code",[e._v("x")]),e._v(" 处于等待态（pending）, "),_("code",[e._v("promise")]),e._v(" 需保持为等待态（pending）直至 "),_("code",[e._v("x")]),e._v(" 为完成态（Fulfilled）或拒绝（Rejected）")])]),e._v(" "),_("li",[_("p",[e._v("2.3.2.2 如果 "),_("code",[e._v("x")]),e._v(" 处于完成态（Fulfilled），用相同的值（value）完成（Fulfill） "),_("code",[e._v("promise")])])]),e._v(" "),_("li",[_("p",[e._v("2.3.2.3 如果 "),_("code",[e._v("x")]),e._v(" 处于拒绝态（Rejected），用相同的原因（reason）拒绝（reject）"),_("code",[e._v("promise")])])])])]),e._v(" "),_("li",[_("p",[e._v("2.3.3. 另外，如果 "),_("code",[e._v("x")]),e._v(" 是对象或者函数")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.3.3.1. 把 "),_("code",[e._v("x.then")]),e._v(" 赋值给 "),_("code",[e._v("then")]),e._v(" [注释3.5]")])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.2. 如果取 "),_("code",[e._v("x.then")]),e._v(" 的值时抛出错误 "),_("code",[e._v("e")]),e._v(" ，则以 "),_("code",[e._v("e")]),e._v(" 为原因（reason）拒绝（reject） "),_("code",[e._v("promise")])])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.3. 如果 "),_("code",[e._v("then")]),e._v(" 是一个函数，那么把 "),_("code",[e._v("x")]),e._v(" 当做 "),_("code",[e._v("this")]),e._v(" 调用它，第一个参数 "),_("code",[e._v("resolvePromise")]),e._v(" ，第二个参数 "),_("code",[e._v("rejectPromise")]),e._v("，其中：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.3.3.3.1 如果使用值（value） "),_("code",[e._v("y")]),e._v(" 为参数来调用 "),_("code",[e._v("resolvePromise")]),e._v(" ，则运行 "),_("code",[e._v("[[Resolve]](promise, y)")])])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.3.2 如果调用 "),_("code",[e._v("rejectPromise")]),e._v(" 的参数是原因（reason）是 "),_("code",[e._v("r")]),e._v(" 时，则使用原因（reason）"),_("code",[e._v("r")]),e._v(" 来拒绝（reject）"),_("code",[e._v("promise")])])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.3.3 如果 "),_("code",[e._v("resolvePromise")]),e._v(" 和 "),_("code",[e._v("rejectPromise")]),e._v(" 同时被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用")])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.3.4 如果调用 "),_("code",[e._v("then")]),e._v(" 抛出了异常e，")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("2.3.3.3.4.1 如果已经调用了 "),_("code",[e._v("resolvePromise")]),e._v(" 或 "),_("code",[e._v("rejectPromise")]),e._v("，则忽略。")])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.3.4.2 否则，以 "),_("code",[e._v("e")]),e._v(" 为原因 "),_("code",[e._v("reason")]),e._v(" 拒绝（reject）"),_("code",[e._v("promise")])])])])])])]),e._v(" "),_("li",[_("p",[e._v("2.3.3.4. 如果 "),_("code",[e._v("then")]),e._v(" 不是一个函数，则以 "),_("code",[e._v("x")]),e._v(" 为参数完成（fulfill）"),_("code",[e._v("promise")])])])])]),e._v(" "),_("li",[_("p",[e._v("2.3.4. 如果 "),_("code",[e._v("x")]),e._v(" 不为对象或者函数，以 "),_("code",[e._v("x")]),e._v(" 为参数完成（fulfill） "),_("code",[e._v("promise")])])])]),e._v(" "),_("p",[e._v("如果一个 "),_("code",[e._v("promise")]),e._v(" 是用一个参与循环 "),_("code",[e._v("thenable")]),e._v(" 链的 "),_("code",[e._v("thenable")]),e._v(" 来解析的，那么 "),_("code",[e._v("[[Resolve]]（promise，thenable）")]),e._v(" 的递归性质最终会导致再次调用 "),_("code",[e._v("[[Resolve]]（promise，thenable）")]),e._v("，遵循上述算法将导致无限递归。我们鼓励但不要求实现检测这种递归，并以 "),_("code",[e._v("TypeError")]),e._v(" 错误为理由（reason）拒绝（reject） "),_("code",[e._v("promise")])]),e._v(" "),_("h2",{attrs:{id:"_3-注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-注释"}},[e._v("#")]),e._v(" 3. 注释")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("3.1. 这里的 "),_("strong",[e._v("“平台代码“")]),e._v(" 指的是引擎、环境和 "),_("code",[e._v("promise")]),e._v(" 实现代码。在实践中，该要求确保在调用 "),_("code",[e._v("then")]),e._v(" 方法被调用的那一轮的事件循环之后，使用新堆栈异步执行 "),_("code",[e._v("onFulfilled")]),e._v(" 和 "),_("code",[e._v("onRejected")]),e._v(" 。这可以通过“宏任务”机制（如setTimeout 或 setImmediate ）或“微任务”机制（如 MutationObserver 或 process.nextTick ）实现。由于 "),_("code",[e._v("promise")]),e._v(" 实现被认为是平台代码（"),_("strong",[e._v("注：")]),e._v(" 即都是 JavaScript），因此它本身可能包含一个任务调度队列或调用处理程序的“trampoline”。")])]),e._v(" "),_("li",[_("p",[e._v("3.2. 也就是说在 "),_("strong",[e._v("严格模式（strict）")]),e._v(" 中，函数 "),_("code",[e._v("this")]),e._v(" 的值为 "),_("code",[e._v("undefined")]),e._v(" ；在非严格模式中其为全局对象。")])]),e._v(" "),_("li",[_("p",[e._v("3.3. 代码实现在满足所有要求的情况下，可以允许 "),_("code",[e._v("promise2 === promise1")]),e._v(" 。每个实现都要文档说明其是否允许以及在何种条件下允许 "),_("code",[e._v("promise2 === promise1")]),e._v(" 。")])]),e._v(" "),_("li",[_("p",[e._v("3.4. 总体来说，如果 "),_("code",[e._v("x")]),e._v(" 符合当前实现，我们才认为它是真正的 "),_("code",[e._v("promise")]),e._v(" 。本规则允许那些特例实现接受符合已知要求的 "),_("code",[e._v("Promises")]),e._v(" 状态。")])]),e._v(" "),_("li",[_("p",[e._v("3.5. 这步我们先是存储了一个指向 "),_("code",[e._v("x.then")]),e._v(" 的引用，然后测试并调用该引用，以避免多次访问 "),_("code",[e._v("x.then")]),e._v(" 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。")])]),e._v(" "),_("li",[_("p",[e._v("3.6 实现不应该对 "),_("code",[e._v("thenable")]),e._v(" 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 "),_("code",[e._v("TypeError")]),e._v(" 异常；如果一条无限长的链上 "),_("code",[e._v("thenable")]),e._v(" 均不相同，那么递归下去永远是正确的行为。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);